<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Scroll Component Test</title>
  <style>
    * {
      padding: 0;
      margin: 0;
    }
    html,body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #2d3748;
      -ms-touch-action: none;
      touch-action: none;
    }
    canvas {
      -ms-touch-action: none;
      touch-action: none;
      touch-action-delay: none;
      -webkit-tap-highlight-color: rgba(0,0,0,0);
      -moz-tap-highlight-color: rgba(0,0,0,0);
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      outline: none;
      border: none;
      width: 100%;
      height: 100%;
    }
    #info {
      position: fixed;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 10px;
      font-family: monospace;
      font-size: 12px;
      border-radius: 4px;
      pointer-events: none;
      z-index: 1000;
    }
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div id="info">
    <div>Scroll Progress: <span id="progress">0%</span></div>
    <div>Touch and drag to scroll</div>
  </div>

  <script src="../../core/dist/tiny-ui-core.js"></script>
  <script src="../dist/tiny-ui-components.js"></script>
  <script>
    const canvas = document.getElementById('game');
    const tinyUI = new TinyUI(canvas);
    const { adjustTo } = TinyUIComponents.utils;
    const dpr = window.devicePixelRatio || 1;

    // 基础尺寸（按 DPR 放大）
    const scrollWidth = 400 * dpr;
    const scrollHeight = 600 * dpr;
    const itemHeight = 100 * dpr;
    const itemSpacing = 20 * dpr;
    const padding = 20 * dpr;
    const fontSize = 24 * dpr;
    const cornerRadius = 10 * dpr;
    
    // 创建滚动区域
    const scroll = TinyUIComponents.Scroll({
      app: tinyUI,
      width: scrollWidth,
      height: scrollHeight,
      direction: 'vertical',
      bounce: true,
      momentum: true,
      scrollbar: {
        width: 6 * dpr,
        radius: 3 * dpr,
        color: 'rgba(255,255,255,0.5)',
        autoHide: true,
        hideDelay: 1500,
      },
      onScroll: (pos) => {
        const progressEl = document.getElementById('progress');
        progressEl.textContent = Math.round(pos.progressY * 100) + '%';
      }
    });

    // 添加到根节点
    tinyUI.root.addChild(scroll.container);

    // 居中显示（使用 adjustTo 对齐到屏幕中心）
    // willContain=true 因为 scroll.container 是 root 的子节点
    adjustTo(tinyUI.root, true)(scroll.container, { h: 'center', v: 'center' });

    // 添加白色背景（带圆角）
    const bg = tinyUI.createGraphics('Scroll/Bg');
    bg.anchorX = 0;
    bg.anchorY = 0;
    bg.drawRoundedRect(0, 0, scrollWidth, scrollHeight, cornerRadius, '#ffffff');
    scroll.container.addChildAt(bg, 0);

    // 添加测试内容
    const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E2'];
    
    for (let i = 0; i < 30; i++) {
      const itemY = padding + i * (itemHeight + itemSpacing);
      const color = colors[i % colors.length];
      
      // 创建容器作为 item
      const item = tinyUI.createContainer('Scroll/Item' + i);
      item.width = scrollWidth - padding * 2;
      item.height = itemHeight;
      item.anchorX = 0;
      item.anchorY = 0;
      item.x = padding;
      item.y = itemY;
      
      // 创建圆角矩形背景
      const itemBg = tinyUI.createGraphics('Scroll/ItemBg' + i);
      itemBg.anchorX = 0;
      itemBg.anchorY = 0;
      itemBg.drawRoundedRect(0, 0, item.width, item.height, cornerRadius, color);
      item.addChild(itemBg);
      
      // 添加文字
      const text = tinyUI.createText('Item ' + (i + 1) + ' - Scroll Test');
      text.color = '#ffffff';
      text.fontSize = fontSize;
      text.anchorX = 0;
      text.anchorY = 0;
      text.updateTexture(); // 强制更新纹理以获取正确尺寸
      
      // 先添加文字到 item，再用 adjustTo 居中对齐
      // willContain=true 因为 text 是 item 的子节点
      item.addChild(text);
      adjustTo(item, true)(text, { h: 'center', v: 'center' });
      
      scroll.content.addChild(item);
    }

    // 渲染循环
    function render() {
      tinyUI.render();
      requestAnimationFrame(render);
    }
    render();
  </script>
</body>
</html>
