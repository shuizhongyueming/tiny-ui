<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Text Wrapping Test - Tiny UI</title>
    <style>
    * {
      padding: 0;
      margin: 0;
    }
    html,body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      width: 100%;
      height: 100%;
      background: #2d3748;
    }
    canvas {
      width: 100%;
      height: 100%;
      display: block;
    }
    </style>
  </head>
  <body>
    <canvas id="game"></canvas>
    <script src="../dist/tiny-ui-core.js"></script>
    <script>
    const canvas = document.getElementById('game');
    const tinyUI = new TinyUI(canvas);

    // 辅助函数：强制更新纹理以获取正确尺寸
    function forceUpdateTexture(text) {
      text.updateTexture();
      return text;
    }

    // 标题
    const title = tinyUI.createText('Text Wrapping & MaxWidth Test');
    title.color = '#ffffff';
    title.fontSize = 40;
    title.anchorX = 0;
    title.anchorY = 0;
    title.x = 50;
    title.y = 30;
    tinyUI.root.addChild(title);

    let yOffset = 120;
    const xBase = 50;
    const testWidth = 350;
    const columnSpacing = 150; // 列间距

    // 测试 1: 普通英文段落
    const label1 = tinyUI.createText('Test 1: Normal English Paragraph (maxWidth=350)');
    label1.color = '#cbd5e0';
    label1.fontSize = 18;
    label1.anchorX = 0;
    label1.anchorY = 0;
    label1.x = xBase;
    label1.y = yOffset;
    tinyUI.root.addChild(label1);

    const text1 = tinyUI.createText('This is a normal paragraph with regular English words. It should wrap correctly based on word boundaries when reaching the maximum width limit.');
    text1.color = '#ffffff';
    text1.fontSize = 20;
    text1.maxWidth = testWidth;
    text1.anchorX = 0;
    text1.anchorY = 0;
    text1.x = xBase;
    text1.y = yOffset + 30;
    text1.align = 'left';
    forceUpdateTexture(text1);
    tinyUI.root.addChild(text1);

    // 背景框参考线
    const bg1 = tinyUI.createGraphics();
    bg1.anchorX = 0;
    bg1.anchorY = 0;
    bg1.drawRect(0, 0, testWidth, text1.height, 'rgba(74, 85, 104, 0.3)');
    bg1.x = xBase;
    bg1.y = yOffset + 30;
    tinyUI.root.addChild(bg1);

    yOffset += text1.height + 100;

    // 测试 2: 超长无空格字符串
    const label2 = tinyUI.createText('Test 2: Very Long String Without Spaces (maxWidth=350)');
    label2.color = '#cbd5e0';
    label2.fontSize = 18;
    label2.anchorX = 0;
    label2.anchorY = 0;
    label2.x = xBase;
    label2.y = yOffset;
    tinyUI.root.addChild(label2);

    const text2 = tinyUI.createText('verylooooongwordwithoutanyspacesatallthisshouldstillbedisplayedbutwillexceedthemaxwidthlimitbecauseitcannotbewrapped');
    text2.color = '#fbbf24';
    text2.fontSize = 20;
    text2.maxWidth = testWidth;
    text2.anchorX = 0;
    text2.anchorY = 0;
    text2.x = xBase;
    text2.y = yOffset + 30;
    forceUpdateTexture(text2);
    tinyUI.root.addChild(text2);

    const bg2 = tinyUI.createGraphics();
    bg2.anchorX = 0;
    bg2.anchorY = 0;
    bg2.drawRect(0, 0, testWidth, text2.height, 'rgba(251, 191, 36, 0.2)');
    bg2.x = xBase;
    bg2.y = yOffset + 30;
    tinyUI.root.addChild(bg2);

    yOffset += text2.height + 80;

    // 测试 3: 混合场景（普通单词 + 超长单词）
    const label3 = tinyUI.createText('Test 3: Mixed (Normal + Super Long Word) (maxWidth=350)');
    label3.color = '#cbd5e0';
    label3.fontSize = 18;
    label3.anchorX = 0;
    label3.anchorY = 0;
    label3.x = xBase;
    label3.y = yOffset;
    tinyUI.root.addChild(label3);

    const text3 = tinyUI.createText('Normal words here superlongunbreakablewordwithoutanyspacesatall and some more normal text after that.');
    text3.color = '#ec4899';
    text3.fontSize = 20;
    text3.maxWidth = testWidth;
    text3.anchorX = 0;
    text3.anchorY = 0;
    text3.x = xBase;
    text3.y = yOffset + 30;
    forceUpdateTexture(text3);
    tinyUI.root.addChild(text3);

    const bg3 = tinyUI.createGraphics();
    bg3.anchorX = 0;
    bg3.anchorY = 0;
    bg3.drawRect(0, 0, testWidth, text3.height, 'rgba(236, 72, 153, 0.2)');
    bg3.x = xBase;
    bg3.y = yOffset + 30;
    tinyUI.root.addChild(bg3);

    yOffset += text3.height + 80;

    // 测试 4: URL 场景
    const label4 = tinyUI.createText('Test 4: URL String (maxWidth=350)');
    label4.color = '#cbd5e0';
    label4.fontSize = 18;
    label4.anchorX = 0;
    label4.anchorY = 0;
    label4.x = xBase;
    label4.y = yOffset;
    tinyUI.root.addChild(label4);

    const text4 = tinyUI.createText('Visit https://github.com/username/repository-name/issues/1234567890 for more information');
    text4.color = '#60a5fa';
    text4.fontSize = 20;
    text4.maxWidth = testWidth;
    text4.anchorX = 0;
    text4.anchorY = 0;
    text4.x = xBase;
    text4.y = yOffset + 30;
    forceUpdateTexture(text4);
    tinyUI.root.addChild(text4);

    const bg4 = tinyUI.createGraphics();
    bg4.anchorX = 0;
    bg4.anchorY = 0;
    bg4.drawRect(0, 0, testWidth, text4.height, 'rgba(96, 165, 250, 0.2)');
    bg4.x = xBase;
    bg4.y = yOffset + 30;
    tinyUI.root.addChild(bg4);

    // 计算第一列最大宽度
    forceUpdateTexture(label1);
    forceUpdateTexture(label2);
    forceUpdateTexture(label3);
    forceUpdateTexture(label4);
    
    const col1MaxWidth = Math.max(
      testWidth,
      label1.width, label2.width, label3.width, label4.width
    );
    
    yOffset = 120;
    const xBase2 = xBase + col1MaxWidth + columnSpacing;

    // 测试 5: 手动换行符 + maxWidth
    const label5 = tinyUI.createText('Test 5: Manual Line Breaks + maxWidth (maxWidth=350)');
    label5.color = '#cbd5e0';
    label5.fontSize = 18;
    label5.anchorX = 0;
    label5.anchorY = 0;
    label5.x = xBase2;
    label5.y = yOffset;
    tinyUI.root.addChild(label5);

    const text5 = tinyUI.createText('First line with manual break\nSecond line also with some longer text that might wrap\nThird line');
    text5.color = '#10b981';
    text5.fontSize = 20;
    text5.maxWidth = testWidth;
    text5.anchorX = 0;
    text5.anchorY = 0;
    text5.x = xBase2;
    text5.y = yOffset + 30;
    forceUpdateTexture(text5);
    tinyUI.root.addChild(text5);

    const bg5 = tinyUI.createGraphics();
    bg5.anchorX = 0;
    bg5.anchorY = 0;
    bg5.drawRect(0, 0, testWidth, text5.height, 'rgba(16, 185, 129, 0.2)');
    bg5.x = xBase2;
    bg5.y = yOffset + 30;
    tinyUI.root.addChild(bg5);

    yOffset += text5.height + 100;

    // 测试 6: 边界情况 - 单词刚好等于 maxWidth
    const label6 = tinyUI.createText('Test 6: Single Short Word (maxWidth=100)');
    label6.color = '#cbd5e0';
    label6.fontSize = 18;
    label6.anchorX = 0;
    label6.anchorY = 0;
    label6.x = xBase2;
    label6.y = yOffset;
    tinyUI.root.addChild(label6);

    const text6 = tinyUI.createText('Short');
    text6.color = '#a78bfa';
    text6.fontSize = 20;
    text6.maxWidth = 100;
    text6.anchorX = 0;
    text6.anchorY = 0;
    text6.x = xBase2;
    text6.y = yOffset + 30;
    forceUpdateTexture(text6);
    tinyUI.root.addChild(text6);

    const bg6 = tinyUI.createGraphics();
    bg6.anchorX = 0;
    bg6.anchorY = 0;
    bg6.drawRect(0, 0, 100, text6.height, 'rgba(167, 139, 250, 0.2)');
    bg6.x = xBase2;
    bg6.y = yOffset + 30;
    tinyUI.root.addChild(bg6);

    yOffset += text6.height + 80;

    // 测试 7: 多个空格
    const label7 = tinyUI.createText('Test 7: Multiple Spaces (maxWidth=350)');
    label7.color = '#cbd5e0';
    label7.fontSize = 18;
    label7.anchorX = 0;
    label7.anchorY = 0;
    label7.x = xBase2;
    label7.y = yOffset;
    tinyUI.root.addChild(label7);

    const text7 = tinyUI.createText('Word1    Word2     Word3   Word4 with multiple spaces between them should still work fine');
    text7.color = '#f59e0b';
    text7.fontSize = 20;
    text7.maxWidth = testWidth;
    text7.anchorX = 0;
    text7.anchorY = 0;
    text7.x = xBase2;
    text7.y = yOffset + 30;
    forceUpdateTexture(text7);
    tinyUI.root.addChild(text7);

    const bg7 = tinyUI.createGraphics();
    bg7.anchorX = 0;
    bg7.anchorY = 0;
    bg7.drawRect(0, 0, testWidth, text7.height, 'rgba(245, 158, 11, 0.2)');
    bg7.x = xBase2;
    bg7.y = yOffset + 30;
    tinyUI.root.addChild(bg7);

    yOffset += text7.height + 80;

    // 测试 8: 空字符串
    const label8 = tinyUI.createText('Test 8: Empty String (maxWidth=350)');
    label8.color = '#cbd5e0';
    label8.fontSize = 18;
    label8.anchorX = 0;
    label8.anchorY = 0;
    label8.x = xBase2;
    label8.y = yOffset;
    tinyUI.root.addChild(label8);

    const text8 = tinyUI.createText('');
    text8.color = '#ef4444';
    text8.fontSize = 20;
    text8.maxWidth = testWidth;
    text8.anchorX = 0;
    text8.anchorY = 0;
    text8.x = xBase2;
    text8.y = yOffset + 30;
    forceUpdateTexture(text8);
    tinyUI.root.addChild(text8);

    const bg8 = tinyUI.createGraphics();
    bg8.anchorX = 0;
    bg8.anchorY = 0;
    bg8.drawRect(0, 0, testWidth, Math.max(text8.height, 30), 'rgba(239, 68, 68, 0.2)');
    bg8.x = xBase2;
    bg8.y = yOffset + 30;
    tinyUI.root.addChild(bg8);

    const emptyLabel = tinyUI.createText('(Empty - should render nothing)');
    emptyLabel.color = '#94a3b8';
    emptyLabel.fontSize = 14;
    emptyLabel.anchorX = 0;
    emptyLabel.anchorY = 0;
    emptyLabel.x = xBase2;
    emptyLabel.y = yOffset + 35;
    tinyUI.root.addChild(emptyLabel);

    // 图例说明
    yOffset += Math.max(text8.height, 30) + 80;

    // 测试 9: 中文段落（无空格分词）
    const label9 = tinyUI.createText('Test 9: Chinese Paragraph (No Space Delimiters) (maxWidth=350)');
    label9.color = '#cbd5e0';
    label9.fontSize = 18;
    label9.anchorX = 0;
    label9.anchorY = 0;
    label9.x = xBase2;
    label9.y = yOffset;
    tinyUI.root.addChild(label9);

    const text9 = tinyUI.createText('这是一段中文测试文本，用于验证没有空格分隔的语言是否能够正确处理。中文不像英文有明确的单词边界。');
    text9.color = '#34d399';
    text9.fontSize = 20;
    text9.maxWidth = testWidth;
    text9.anchorX = 0;
    text9.anchorY = 0;
    text9.x = xBase2;
    text9.y = yOffset + 30;
    forceUpdateTexture(text9);
    tinyUI.root.addChild(text9);

    const bg9 = tinyUI.createGraphics();
    bg9.anchorX = 0;
    bg9.anchorY = 0;
    bg9.drawRect(0, 0, testWidth, text9.height, 'rgba(52, 211, 153, 0.2)');
    bg9.x = xBase2;
    bg9.y = yOffset + 30;
    tinyUI.root.addChild(bg9);

    const notice9 = tinyUI.createText('✅ Chinese NOW wraps (char by char)');
    notice9.color = '#4ade80';
    notice9.fontSize = 14;
    notice9.anchorX = 0;
    notice9.anchorY = 0;
    notice9.x = xBase2;
    notice9.y = yOffset + 35 + text9.height;
    forceUpdateTexture(notice9);
    tinyUI.root.addChild(notice9);

    // 计算第二列最大宽度
    forceUpdateTexture(label5);
    forceUpdateTexture(label6);
    forceUpdateTexture(label7);
    forceUpdateTexture(label8);
    forceUpdateTexture(label9);
    
    const col2MaxWidth = Math.max(
      testWidth,
      label5.width, label6.width, label7.width, label8.width, label9.width
    );
    
    yOffset = 120;
    const xBase3 = xBase2 + col2MaxWidth + columnSpacing;

    // 测试 10: 中英文混合
    const label10 = tinyUI.createText('Test 10: Mixed Chinese & English (maxWidth=350)');
    label10.color = '#cbd5e0';
    label10.fontSize = 18;
    label10.anchorX = 0;
    label10.anchorY = 0;
    label10.x = xBase3;
    label10.y = yOffset;
    tinyUI.root.addChild(label10);

    const text10 = tinyUI.createText('这是中文 with English words 混合的文本内容，应该在英文单词边界处换行。');
    text10.color = '#fb7185';
    text10.fontSize = 20;
    text10.maxWidth = testWidth;
    text10.anchorX = 0;
    text10.anchorY = 0;
    text10.x = xBase3;
    text10.y = yOffset + 30;
    forceUpdateTexture(text10);
    tinyUI.root.addChild(text10);

    const bg10 = tinyUI.createGraphics();
    bg10.anchorX = 0;
    bg10.anchorY = 0;
    bg10.drawRect(0, 0, testWidth, text10.height, 'rgba(251, 113, 133, 0.2)');
    bg10.x = xBase3;
    bg10.y = yOffset + 30;
    tinyUI.root.addChild(bg10);

    yOffset += text10.height + 100;

    // 测试 11: 带标点的中文
    const label11 = tinyUI.createText('Test 11: Chinese with Punctuation (maxWidth=350)');
    label11.color = '#cbd5e0';
    label11.fontSize = 18;
    label11.anchorX = 0;
    label11.anchorY = 0;
    label11.x = xBase3;
    label11.y = yOffset;
    tinyUI.root.addChild(label11);

    const text11 = tinyUI.createText('中文标点测试：逗号，句号。问号？感叹号！这些标点符号不会触发换行。');
    text11.color = '#c084fc';
    text11.fontSize = 20;
    text11.maxWidth = testWidth;
    text11.anchorX = 0;
    text11.anchorY = 0;
    text11.x = xBase3;
    text11.y = yOffset + 30;
    forceUpdateTexture(text11);
    tinyUI.root.addChild(text11);

    const bg11 = tinyUI.createGraphics();
    bg11.anchorX = 0;
    bg11.anchorY = 0;
    bg11.drawRect(0, 0, testWidth, text11.height, 'rgba(192, 132, 252, 0.2)');
    bg11.x = xBase3;
    bg11.y = yOffset + 30;
    tinyUI.root.addChild(bg11);

    yOffset += text11.height + 80;

    // 测试 12: 日文假名（无空格）
    const label12 = tinyUI.createText('Test 12: Japanese Hiragana (No Spaces) (maxWidth=350)');
    label12.color = '#cbd5e0';
    label12.fontSize = 18;
    label12.anchorX = 0;
    label12.anchorY = 0;
    label12.x = xBase3;
    label12.y = yOffset;
    tinyUI.root.addChild(label12);

    const text12 = tinyUI.createText('これはひらがなのテストです。スペースがないので改行されません。日本語も同じ問題があります。');
    text12.color = '#22d3ee';
    text12.fontSize = 20;
    text12.maxWidth = testWidth;
    text12.anchorX = 0;
    text12.anchorY = 0;
    text12.x = xBase3;
    text12.y = yOffset + 30;
    forceUpdateTexture(text12);
    tinyUI.root.addChild(text12);

    const bg12 = tinyUI.createGraphics();
    bg12.anchorX = 0;
    bg12.anchorY = 0;
    bg12.drawRect(0, 0, testWidth, text12.height, 'rgba(34, 211, 238, 0.2)');
    bg12.x = xBase3;
    bg12.y = yOffset + 30;
    tinyUI.root.addChild(bg12);

    const notice12 = tinyUI.createText('✅ Japanese NOW wraps (char by char)');
    notice12.color = '#4ade80';
    notice12.fontSize = 14;
    notice12.anchorX = 0;
    notice12.anchorY = 0;
    notice12.x = xBase3;
    notice12.y = yOffset + 35 + text12.height;
    forceUpdateTexture(notice12);
    tinyUI.root.addChild(notice12);

    yOffset += text12.height + 80;

    // 测试 13: 用空格分隔的中文（人为添加）
    const label13 = tinyUI.createText('Test 13: Chinese with Spaces (Manually Added) (maxWidth=350)');
    label13.color = '#cbd5e0';
    label13.fontSize = 18;
    label13.anchorX = 0;
    label13.anchorY = 0;
    label13.x = xBase3;
    label13.y = yOffset;
    tinyUI.root.addChild(label13);

    const text13 = tinyUI.createText('这是 一段 人为 添加 空格 的 中文 文本 应该 可以 正确 换行 因为 有 空格 分隔');
    text13.color = '#4ade80';
    text13.fontSize = 20;
    text13.maxWidth = testWidth;
    text13.anchorX = 0;
    text13.anchorY = 0;
    text13.x = xBase3;
    text13.y = yOffset + 30;
    forceUpdateTexture(text13);
    tinyUI.root.addChild(text13);

    const bg13 = tinyUI.createGraphics();
    bg13.anchorX = 0;
    bg13.anchorY = 0;
    bg13.drawRect(0, 0, testWidth, text13.height, 'rgba(74, 222, 128, 0.2)');
    bg13.x = xBase3;
    bg13.y = yOffset + 30;
    tinyUI.root.addChild(bg13);

    const notice13 = tinyUI.createText('✅ This WILL wrap (has spaces)');
    notice13.color = '#4ade80';
    notice13.fontSize = 14;
    notice13.anchorX = 0;
    notice13.anchorY = 0;
    notice13.x = xBase3;
    notice13.y = yOffset + 35 + text13.height;
    forceUpdateTexture(notice13);
    tinyUI.root.addChild(notice13);

    // 计算第三列的结束位置
    const col3EndY = yOffset + 35 + text13.height + 50;
    
    // ============================================
    // BBCode 测试区域（紧贴着前面的测试）
    // ============================================
    
    // 计算 BBCode 区域的起始 y 位置（取所有列的最大值）
    // 第一列结束: Test 4 (text4)
    // 第二列结束: Test 9 (notice9)
    // 第三列结束: Test 13 (notice13)
    const col1EndY = text4.y + text4.height + 100;
    const col2EndY = notice9.y + notice9.height + 50;
    const maxYOffset = Math.max(col1EndY, col2EndY, col3EndY) + 60;
    
    // 重置 yOffset 用于 BBCode 测试（使用第一列位置）
    yOffset = maxYOffset;

    const bbcodeTitle = tinyUI.createText('=== BBCode Text Wrapping Tests ===');
    bbcodeTitle.color = '#fbbf24';
    bbcodeTitle.fontSize = 28;
    bbcodeTitle.anchorX = 0;
    bbcodeTitle.anchorY = 0;
    bbcodeTitle.x = 50;
    bbcodeTitle.y = yOffset;
    tinyUI.root.addChild(bbcodeTitle);

    yOffset += 50;

    // 测试 14: BBCode 普通文本换行
    const label14 = tinyUI.createText('Test 14: BBCode Normal Text (maxWidth=350)');
    label14.color = '#cbd5e0';
    label14.fontSize = 18;
    label14.anchorX = 0;
    label14.anchorY = 0;
    label14.x = xBase;
    label14.y = yOffset;
    tinyUI.root.addChild(label14);

    const text14 = tinyUI.createText('[b]This is a bold paragraph[/b] with regular English words. It should [color=#ec4899]wrap correctly[/color] based on word boundaries when reaching the maximum width limit.');
    text14.bbcodeEnabled = true;
    text14.color = '#ffffff';
    text14.fontSize = 20;
    text14.maxWidth = testWidth;
    text14.anchorX = 0;
    text14.anchorY = 0;
    text14.x = xBase;
    text14.y = yOffset + 30;
    forceUpdateTexture(text14);
    tinyUI.root.addChild(text14);

    const bg14 = tinyUI.createGraphics();
    bg14.anchorX = 0;
    bg14.anchorY = 0;
    bg14.drawRect(0, 0, testWidth, text14.height, 'rgba(251, 191, 36, 0.3)');
    bg14.x = xBase;
    bg14.y = yOffset + 30;
    tinyUI.root.addChild(bg14);

    const col1YOffset = yOffset + text14.height + 100;

    // 测试 15: BBCode 超长无空格字符串
    const label15 = tinyUI.createText('Test 15: BBCode Long String Without Spaces (maxWidth=350)');
    label15.color = '#cbd5e0';
    label15.fontSize = 18;
    label15.anchorX = 0;
    label15.anchorY = 0;
    label15.x = xBase;
    label15.y = col1YOffset;
    tinyUI.root.addChild(label15);

    const text15 = tinyUI.createText('[b][color=#fbbf24]verylooooongwordwithoutanyspaces[/color][/b]atallthisshouldstillbedisplayedbutwillexceedthemaxwidthlimitbecauseitcannotbewrapped');
    text15.bbcodeEnabled = true;
    text15.color = '#fbbf24';
    text15.fontSize = 20;
    text15.maxWidth = testWidth;
    text15.anchorX = 0;
    text15.anchorY = 0;
    text15.x = xBase;
    text15.y = col1YOffset + 30;
    forceUpdateTexture(text15);
    tinyUI.root.addChild(text15);

    const bg15 = tinyUI.createGraphics();
    bg15.anchorX = 0;
    bg15.anchorY = 0;
    bg15.drawRect(0, 0, testWidth, text15.height, 'rgba(251, 191, 36, 0.2)');
    bg15.x = xBase;
    bg15.y = col1YOffset + 30;
    tinyUI.root.addChild(bg15);

    // 第二列 BBCode 测试
    yOffset = maxYOffset + 60;

    // 测试 16: BBCode 中文文本换行
    const label16 = tinyUI.createText('Test 16: BBCode Chinese Text (maxWidth=350)');
    label16.color = '#cbd5e0';
    label16.fontSize = 18;
    label16.anchorX = 0;
    label16.anchorY = 0;
    label16.x = xBase2;
    label16.y = yOffset;
    tinyUI.root.addChild(label16);

    const text16 = tinyUI.createText('[b][color=#34d399]这是一段中文测试文本[/color][/b]，用于验证 BBCode 模式下没有空格分隔的语言是否能够正确处理换行。');
    text16.bbcodeEnabled = true;
    text16.color = '#34d399';
    text16.fontSize = 20;
    text16.maxWidth = testWidth;
    text16.anchorX = 0;
    text16.anchorY = 0;
    text16.x = xBase2;
    text16.y = yOffset + 30;
    forceUpdateTexture(text16);
    tinyUI.root.addChild(text16);

    const bg16 = tinyUI.createGraphics();
    bg16.anchorX = 0;
    bg16.anchorY = 0;
    bg16.drawRect(0, 0, testWidth, text16.height, 'rgba(52, 211, 153, 0.3)');
    bg16.x = xBase2;
    bg16.y = yOffset + 30;
    tinyUI.root.addChild(bg16);

    const notice16 = tinyUI.createText('✅ BBCode Chinese wraps (char by char)');
    notice16.color = '#4ade80';
    notice16.fontSize = 14;
    notice16.anchorX = 0;
    notice16.anchorY = 0;
    notice16.x = xBase2;
    notice16.y = yOffset + 35 + text16.height;
    forceUpdateTexture(notice16);
    tinyUI.root.addChild(notice16);

    // 测试 17: BBCode 混合超长内容
    const label17 = tinyUI.createText('Test 17: BBCode Mixed Long Content (maxWidth=350)');
    label17.color = '#cbd5e0';
    label17.fontSize = 18;
    label17.anchorX = 0;
    label17.anchorY = 0;
    label17.x = xBase2;
    label17.y = yOffset + text16.height + 80;
    tinyUI.root.addChild(label17);

    const text17 = tinyUI.createText('Normal [b]bold text[/b] and [color=#ec4899]superlongunbreakablewordwithoutanyspacesatall[/color] and then more [u]underlined text[/u] after that.');
    text17.bbcodeEnabled = true;
    text17.color = '#ec4899';
    text17.fontSize = 20;
    text17.maxWidth = testWidth;
    text17.anchorX = 0;
    text17.anchorY = 0;
    text17.x = xBase2;
    text17.y = yOffset + text16.height + 110;
    forceUpdateTexture(text17);
    tinyUI.root.addChild(text17);

    const bg17 = tinyUI.createGraphics();
    bg17.anchorX = 0;
    bg17.anchorY = 0;
    bg17.drawRect(0, 0, testWidth, text17.height, 'rgba(236, 72, 153, 0.2)');
    bg17.x = xBase2;
    bg17.y = yOffset + text16.height + 110;
    tinyUI.root.addChild(bg17);

    // 第三列 BBCode 测试
    // 测试 18: BBCode 多标签嵌套
    const label18 = tinyUI.createText('Test 18: BBCode Nested Tags (maxWidth=350)');
    label18.color = '#cbd5e0';
    label18.fontSize = 18;
    label18.anchorX = 0;
    label18.anchorY = 0;
    label18.x = xBase3;
    label18.y = yOffset;
    tinyUI.root.addChild(label18);

    const text18 = tinyUI.createText('[size=1.2][b][color=#60a5fa]Large Bold Blue[/color][/b][/size] and then some regular text that should wrap correctly when it reaches the maximum width limit set for this test case.');
    text18.bbcodeEnabled = true;
    text18.color = '#ffffff';
    text18.fontSize = 20;
    text18.maxWidth = testWidth;
    text18.anchorX = 0;
    text18.anchorY = 0;
    text18.x = xBase3;
    text18.y = yOffset + 30;
    forceUpdateTexture(text18);
    tinyUI.root.addChild(text18);

    const bg18 = tinyUI.createGraphics();
    bg18.anchorX = 0;
    bg18.anchorY = 0;
    bg18.drawRect(0, 0, testWidth, text18.height, 'rgba(96, 165, 250, 0.3)');
    bg18.x = xBase3;
    bg18.y = yOffset + 30;
    tinyUI.root.addChild(bg18);

    // 计算 BBCode 各列的结束位置
    const bbcodeCol1End = col1YOffset + text15.height + 50;
    const bbcodeCol2End = yOffset + 35 + text16.height + text17.height + 150;
    const bbcodeCol3End = yOffset + 30 + text18.height + 50;
    
    // 图例说明
    const finalYOffset = Math.max(bbcodeCol1End, bbcodeCol2End, bbcodeCol3End);
    
    const legend = tinyUI.createText('Legend: Colored backgrounds show maxWidth boundary | ✅ All text now wraps (char-level for CJK) | BBCode: Yellow/Green/Blue show maxWidth');
    legend.color = '#94a3b8';
    legend.fontSize = 16;
    legend.anchorX = 0;
    legend.anchorY = 0;
    legend.x = 50;
    legend.y = finalYOffset + 40;
    forceUpdateTexture(legend);
    tinyUI.root.addChild(legend);

    tinyUI.render();
    </script>
  </body>
</html>
